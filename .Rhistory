# Group by 'Company' and calculate total volume
total_volume <- selected_data %>%
group_by(Company) %>%
summarise(Total_Volume = sum(Volume)) %>%
arrange(desc(Total_Volume))  # Sort by total volume in descending order
# Select the top 10 companies
top_10_companies <- total_volume %>%
top_n(10, Total_Volume)
# Increase plot size
options(repr.plot.width = 10, repr.plot.height = 6)  # Adjust width and height as needed
# Plot bar chart with custom design
barplot(top_10_companies$Total_Volume,
names.arg = top_10_companies$Company,
xlab = "Company",
ylab = "Total Volume",
main = "Top 10 Companies with Highest Total Volume in Last 6 Months",
col = rainbow(nrow(top_10_companies)),  # Custom color palette
border = "black",
ylim = c(0, max(total_volume$Total_Volume) * 1.2),
las = 2,  # Rotate company names if needed for better visualization
cex.names = 0.8,  # Adjust font size for company names
cex.lab = 1.2,  # Adjust font size for axis labels
cex.main = 1.5,  # Adjust font size for main title
width = 0.5)  # Adjust bar width as needed
# Load required libraries
library(randomForest)
# Load required libraries
install.packages("randomForest")
library(randomForest)
# Ensure 'Data' is sorted by date
Data <- Data[order(Data$Date), ]
# Ensure 'data' is sorted by date
data <- data[order(data$Date), ]
# Feature engineering: Create lagged variables for previous closing prices
lagged_prices <- c(1, 2, 3, 4, 5)  # Lagged periods
for (lag in lagged_prices) {
data[[paste0("Close_lag", lag)]] <- lag(data$Close, lag)
}
# Split the data into training and testing sets
train_size <- 0.8  # 80% of data for training
train_index <- 1:round(nrow(data) * train_size)
train_data <- data[train_index, ]
test_data <- data[-train_index, ]
# Define features and target variable
features <- c("Close_lag1", "Close_lag2", "Close_lag3", "Close_lag4", "Close_lag5")
target <- "Close"
# Train the Random Forest model
rf_model <- randomForest(as.formula(paste(target, "~", paste(features, collapse = " + "))),
data = train_data, ntree = 500)
# Filter data for AMD
amd_data <- data[data$Company == "Advanced Micro Devices, Inc.", ]
# Impute missing values with mean for AMD
amd_data$Close <- ifelse(is.na(amd_data$Close), mean(amd_data$Close, na.rm = TRUE), amd_data$Close)
# Ensure 'amd_data' is sorted by date
amd_data <- amd_data[order(amd_data$Date), ]
# Feature engineering: Create lagged variables for previous closing prices
lagged_prices <- c(1, 2, 3, 4, 5)  # Lagged periods
for (lag in lagged_prices) {
amd_data[[paste0("Close_lag", lag)]] <- lag(amd_data$Close, lag)
}
# Split the data into training and testing sets
train_size <- 0.8  # 80% of data for training
train_index <- 1:round(nrow(amd_data) * train_size)
train_data <- amd_data[train_index, ]
test_data <- amd_data[-train_index, ]
# Define features and target variable
features <- c("Close_lag1", "Close_lag2", "Close_lag3", "Close_lag4", "Close_lag5")
target <- "Close"
# Train the Random Forest model for AMD
rf_model <- randomForest(as.formula(paste(target, "~", paste(features, collapse = " + "))),
data = train_data, ntree = 500)
View(amd_data)
# Filter data for AMD
amd_data <- data[data$Company == "Advanced Micro Devices, Inc.", ]
# Impute missing values with mean for AMD
amd_data$Close <- ifelse(is.na(amd_data$Close), mean(amd_data$Close, na.rm = TRUE), amd_data$Close)
# Ensure 'amd_data' is sorted by date
amd_data <- amd_data[order(amd_data$Date), ]
# Feature engineering: Create lagged variables for previous closing prices
lagged_prices <- c(1, 2, 3, 4, 5)  # Lagged periods
for (lag in lagged_prices) {
amd_data[[paste0("Close_lag", lag)]] <- lag(amd_data$Close, lag)
}
# Remove rows with NA values in lagged variables
amd_data <- na.omit(amd_data)
# Split the data into training and testing sets
train_size <- 0.8  # 80% of data for training
train_index <- 1:round(nrow(amd_data) * train_size)
train_data <- amd_data[train_index, ]
test_data <- amd_data[-train_index, ]
# Define features and target variable
features <- c("Close_lag1", "Close_lag2", "Close_lag3", "Close_lag4", "Close_lag5")
target <- "Close"
# Train the Random Forest model for AMD
rf_model <- randomForest(as.formula(paste(target, "~", paste(features, collapse = " + "))),
data = train_data, ntree = 500)
# Make predictions on the test data
predictions <- predict(rf_model, test_data)
# Calculate accuracy metrics
accuracy_metrics <- function(actual, predicted) {
mae <- mean(abs(actual - predicted))  # Mean Absolute Error (MAE)
mse <- mean((actual - predicted)^2)   # Mean Squared Error (MSE)
rmse <- sqrt(mse)                     # Root Mean Squared Error (RMSE)
return(c(MAE = mae, MSE = mse, RMSE = rmse))
}
# Calculate accuracy metrics
metrics <- accuracy_metrics(test_data$Close, predictions)
print(metrics)
# Plot actual vs. predicted values
plot(test_data$Close, predictions,
main = "Actual vs. Predicted Close Prices",
xlab = "Actual Close Price", ylab = "Predicted Close Price",
col = "blue", pch = 20)
abline(0, 1, col = "red", lwd = 2)  # Add diagonal line for reference
# Load required library
library(ggplot2)
# Convert 'Date' column to Date type
data$Date <- as.Date(data$Date)
# Specify the companies to include in the plots
selected_companies <- c("American Airlines Group Inc.", "Apple Inc.", "Advanced Micro Devices, Inc.", "Amazon.com, Inc.")
# Filter data for selected companies
selected_data <- data[data$Company %in% selected_companies, ]
# Check for missing values
missing_values <- sum(is.na(data))
# Filter data for the last 6 months
six_months_ago <- Sys.Date() - (6*30)
selected_data <- selected_data[selected_data$Date >= six_months_ago, ]
# Set up layout for plots
par(mfrow = c(2, 2))
# Create individual plots for each selected company - Closing Price
for (company in selected_companies) {
subset_data <- selected_data[selected_data$Company == company, ]
plot(subset_data$Date, subset_data$Close, type = "l",
main = paste("Closing Price Curve for", company),
xlab = "Date", ylab = "Closing Price")
}
# Create individual plots for sales volume for each selected company
for (company in selected_companies) {
subset_data <- selected_data[selected_data$Company == company, ]
plot(subset_data$Date, subset_data$Volume / 1e6, type = "l",
main = paste("Sales Volume for", company),
xlab = "Date", ylab = "Volume (Millions)")
}
# Calculate moving averages for each company
ma_periods <- c(10, 20, 50)  # Moving average periods
# Create plots
par(mfrow = c(3, 1))  # Set up plotting layout
for (period in ma_periods) {
for (company in selected_companies) {
subset_data <- selected_data[selected_data$Company == company, ]
ma_column_name <- paste("MA", period, "Days")
subset_data[[ma_column_name]] <- stats::filter(subset_data$Close, rep(1/period, period), sides=2)
# Plot adjusted close prices and moving averages
plot(subset_data$Date, subset_data$Close, type = "l", col = "blue", xlab = "Date", ylab = "Price",
main = paste("Adjusted Close Prices and Moving Average for", period, "Days"))
lines(subset_data$Date, subset_data[[ma_column_name]], col = "red", lty = "dashed")
legend("topright", legend = c("Adjusted Close", paste("MA", period, "Days")),
col = c("blue", "red"), lty = c("solid", "dashed"), cex = 0.8)
}
}
# Load necessary libraries
library(lmtest)  # For econometric modeling
# Filter data for AMD
amd_data <- data[data$Company == "Advanced Micro Devices, Inc.", ]
missing_values
# Remove rows with missing values
data <- data[complete.cases(data), ]
# Summary statistics for the 'Close' column after cleaning
summary(data$Close)
# Display the cleaned data
data
# Summary statistics for the 'Close' column
summary(data$Close)
# Boxplot to visualize outliers
boxplot(data$Close, main = "Boxplot of Close Prices")
# Calculate the Interquartile Range (IQR)
Q1 <- quantile(data$Close, 0.25)
Q3 <- quantile(data$Close, 0.75)
IQR <- Q3 - Q1
# Define the lower and upper bounds for outlier detection
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
# Identify outliers
outliers <- data$Close[data$Close < lower_bound | data$Close > upper_bound]
# Load required library
library(ggplot2)
# Convert 'Date' column to Date type
data$Date <- as.Date(data$Date)
# Specify the companies to include in the plots
selected_companies <- c("American Airlines Group Inc.", "Apple Inc.", "Advanced Micro Devices, Inc.", "Amazon.com, Inc.")
# Filter data for selected companies
selected_data <- data[data$Company %in% selected_companies, ]
# Filter data for the last 6 months
six_months_ago <- Sys.Date() - (6*30)
selected_data <- selected_data[selected_data$Date >= six_months_ago, ]
# Set up layout for plots
par(mfrow = c(2, 2))
# Create individual plots for each selected company - Closing Price
for (company in selected_companies) {
subset_data <- selected_data[selected_data$Company == company, ]
plot(subset_data$Date, subset_data$Close, type = "l",
main = paste("Closing Price Curve for", company),
xlab = "Date", ylab = "Closing Price")
}
# Create individual plots for sales volume for each selected company
for (company in selected_companies) {
subset_data <- selected_data[selected_data$Company == company, ]
plot(subset_data$Date, subset_data$Volume / 1e6, type = "l",
main = paste("Sales Volume for", company),
xlab = "Date", ylab = "Volume (Millions)")
}
# Calculate moving averages for each company
ma_periods <- c(10, 20, 50)  # Moving average periods
# Create plots
par(mfrow = c(3, 1))  # Set up plotting layout
for (period in ma_periods) {
for (company in selected_companies) {
subset_data <- selected_data[selected_data$Company == company, ]
ma_column_name <- paste("MA", period, "Days")
subset_data[[ma_column_name]] <- stats::filter(subset_data$Close, rep(1/period, period), sides=2)
# Plot adjusted close prices and moving averages
plot(subset_data$Date, subset_data$Close, type = "l", col = "blue", xlab = "Date", ylab = "Price",
main = paste("Adjusted Close Prices and Moving Average for", period, "Days"))
lines(subset_data$Date, subset_data[[ma_column_name]], col = "red", lty = "dashed")
legend("topright", legend = c("Adjusted Close", paste("MA", period, "Days")),
col = c("blue", "red"), lty = c("solid", "dashed"), cex = 0.8)
}
}
# Import libraries
library(readr)
# Specify the path to the CSV file
file_path <- "most_active.csv"
# Load the dataset
data <- read.csv(file_path, header = TRUE)
# Display the first few rows of the dataset for verification
head(data)
# Display the structure of the dataset
str(data)
# Display the summary statistics of the dataset
summary(data)
# Description of the dataset columns:
# - Open: Opening price of the stock. The price at which the first transaction of the day occurred.
# - High: The highest price reached by the stock during the trading day.
# - Low: The lowest price reached by the stock during the trading day.
# - Close: Closing price of the stock. The price at which the last transaction of the day occurred.
# - Adj.Close: Adjusted closing price of the stock. It accounts for any distributions and corporate actions that occurred before the opening of the next day.
# - Volume: Trading volume of the stock, i.e., the total number of shares traded during the trading day.
# Check for missing values
missing_values <- sum(is.na(data))
missing_values
# Remove rows with missing values
data <- data[complete.cases(data), ]
#Check Date Format: Confirm that the 'Date' column is in the correct date format.
library(lubridate)
is.Date(data$Date)
data$Date <- as.Date(data$Date)
# Check unique values in the 'Date' column
length(unique(data$Date)) == nrow(data)
#Check for Negative Values: Ensure that there are no negative values in numerical columns where it's not appropriate (e.g., 'Open', 'High', 'Low', 'Close', 'Adj.Close', 'Volume').
any(data$Open < 0)
any(data$High < 0)
any(data$Low < 0)
any(data$Close < 0)
any(data$Adj.Close < 0)
any(data$Volume < 0)
#Check Consistency: Ensure that 'High' values are greater than or equal to 'Low' values
any(data$High < data$Low)
# Summary statistics for the 'Close' column after cleaning
summary(data$Close)
# Display the cleaned data
data
# Summary statistics for the 'Close' column
summary(data)
# Boxplot to visualize outliers
boxplot(data$Close, main = "Boxplot of Close Prices")
# Calculate the Interquartile Range (IQR)
Q1 <- quantile(data$Close, 0.25)
Q3 <- quantile(data$Close, 0.75)
IQR <- Q3 - Q1
# Define the lower and upper bounds for outlier detection
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
# Identify outliers
outliers <- data$Close[data$Close < lower_bound | data$Close > upper_bound]
# Remove outliers
data_clean <- data[!(data$Close %in% outliers), ]
# Summary statistics for the cleaned dataset
summary(data_clean$Close)
# Boxplot of the cleaned dataset
boxplot(data_clean$Close, main = "Boxplot of Close Prices (Cleaned)")
# Load required library
library(ggplot2)
# Convert 'Date' column to Date type
data$Date <- as.Date(data$Date)
# Specify the companies to include in the plots
selected_companies <- c("American Airlines Group Inc.", "Apple Inc.", "Advanced Micro Devices, Inc.", "Amazon.com, Inc.")
# Filter data for selected companies
selected_data <- data[data$Company %in% selected_companies, ]
# Filter data for the last 2 years
six_months_ago <- as.Date("2022-04-111")
selected_data <- selected_data[selected_data$Date >= six_months_ago, ]
# Set up layout for plots
par(mfrow = c(2, 2))
# Create individual plots for each selected company - Closing Price
for (company in selected_companies) {
subset_data <- selected_data[selected_data$Company == company, ]
plot(subset_data$Date, subset_data$Close, type = "l",
main = paste("Closing Price Curve for", company),
xlab = "Date", ylab = "Closing Price")
}
# Create individual plots for sales volume for each selected company
for (company in selected_companies) {
subset_data <- selected_data[selected_data$Company == company, ]
plot(subset_data$Date, subset_data$Volume / 1e6, type = "l",
main = paste("Sales Volume for", company),
xlab = "Date", ylab = "Volume (Millions)")
}
# Calculate moving averages for each company
ma_periods <- c(10, 20, 50)  # Moving average periods
# Create plots
par(mfrow = c(3, 1))  # Set up plotting layout
for (company in selected_companies) {
for (period in ma_periods) {
subset_data <- selected_data[selected_data$Company == company, ]
ma_column_name <- paste("MA", period, "Days")
subset_data[[ma_column_name]] <- stats::filter(subset_data$Close, rep(1/period, period), sides=2)
# Plot adjusted close prices and moving averages
plot(subset_data$Date, subset_data$Close, type = "l", col = "blue", xlab = "Date", ylab = "Price",
main = paste("Adjusted Close Prices and Moving Average for", period, "Days"))
lines(subset_data$Date, subset_data[[ma_column_name]], col = "red", lty = "dashed")
legend("topright", legend = c("Adjusted Close", paste("MA", period, "Days")),
col = c("blue", "red"), lty = c("solid", "dashed"), cex = 0.8)
}
}
# Load required library
library(ggplot2)
# Convert 'Date' column to Date type
data$Date <- as.Date(data$Date)
# Specify the companies to include in the plots
selected_companies <- c("American Airlines Group Inc.", "Apple Inc.", "Advanced Micro Devices, Inc.", "Amazon.com, Inc.")
# Filter data for selected companies
selected_data <- data[data$Company %in% selected_companies, ]
# Filter data for the last 2 years
six_months_ago <- as.Date("2022-04-111")
selected_data <- selected_data[selected_data$Date >= six_months_ago, ]
# Set up layout for plots
par(mfrow = c(2, 2))
# Create individual plots for each selected company - Closing Price
for (company in selected_companies) {
subset_data <- selected_data[selected_data$Company == company, ]
plot(subset_data$Date, subset_data$Close, type = "l",
main = paste("Closing Price Curve for", company),
xlab = "Date", ylab = "Closing Price")
}
# Create individual plots for sales volume for each selected company
for (company in selected_companies) {
subset_data <- selected_data[selected_data$Company == company, ]
plot(subset_data$Date, subset_data$Volume / 1e6, type = "l",
main = paste("Sales Volume for", company),
xlab = "Date", ylab = "Volume (Millions)")
}
# Calculate moving averages for each company
ma_periods <- c(10, 20, 50)  # Moving average periods
# Create plots
par(mfrow = c(3, 1))  # Set up plotting layout
for (company in selected_companies) {
for (period in ma_periods) {
subset_data <- selected_data[selected_data$Company == company, ]
ma_column_name <- paste("MA", period, "Days")
subset_data[[ma_column_name]] <- stats::filter(subset_data$Close, rep(1/period, period), sides=2)
# Plot adjusted close prices and moving averages
plot(subset_data$Date, subset_data$Close, type = "l", col = "blue", xlab = "Date", ylab = "Price",
main = paste("Adjusted Close Prices and Moving Average for", period, "Days"))
lines(subset_data$Date, subset_data[[ma_column_name]], col = "red", lty = "dashed")
legend("topright", legend = c("Adjusted Close", paste("MA", period, "Days")),
col = c("blue", "red"), lty = c("solid", "dashed"), cex = 0.8)
}
}
# Create plots
par(mfrow = c(1, 1))  # Set up plotting layout
for (company in selected_companies) {
for (period in ma_periods) {
subset_data <- selected_data[selected_data$Company == company, ]
ma_column_name <- paste("MA", period, "Days")
subset_data[[ma_column_name]] <- stats::filter(subset_data$Close, rep(1/period, period), sides=2)
# Plot adjusted close prices and moving averages
plot(subset_data$Date, subset_data$Close, type = "l", col = "blue", xlab = "Date", ylab = "Price",
main = paste("Adjusted Close Prices and Moving Average for", period, "Days"))
lines(subset_data$Date, subset_data[[ma_column_name]], col = "red", lty = "dashed")
legend("topright", legend = c("Adjusted Close", paste("MA", period, "Days")),
col = c("blue", "red"), lty = c("solid", "dashed"), cex = 0.8)
}
}
# Load necessary libraries
library(lmtest)  # For econometric modeling
# Load necessary libraries
library(lmtest)  # For econometric modeling
# Calculate correlation between Open and Close prices
correlation <- cor(selected_data$Open, selected_data$Close)
print(paste("Correlation between Open and Close prices:", correlation))
# Plot the relationship between Open and Close prices
ggplot(selected_data, aes(x = Open, y = Close)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
labs(x = "Open Price", y = "Close Price", title = "Relationship between Open and Close Prices")
# Perform econometric modeling
model <- lm(Close ~ Open, data = selected_data)
print(summary(model))
# Perform heteroscedasticity test
bptest(model)
# Calculate correlation between High and Low columns
correlation <- cor(selected_data$High, selected_data$Low)
# Plot High vs. Low
plot(selected_data$High, selected_data$Low, xlab = "High", ylab = "Low", main = "High vs. Low", pch = 20)
# Print the correlation coefficient
print(correlation)
# Fit an econometric model
model <- lm(Close ~ Open + High + Low + Volume, data = selected_data)
# Summary of the model
summary(model)
library(dplyr)
library(dplyr)
library(dplyr)
# Group by 'Company' and calculate total volume
total_volume <- data %>%
group_by(Company) %>%
summarise(Total_Volume = sum(Volume)) %>%
arrange(desc(Total_Volume))  # Sort by total volume in descending order
# Select the topdata# Select the top 10 companies
top_10_companies <- total_volume %>%
top_n(10, Total_Volume)
# Increase plot size
options(repr.plot.width = 10, repr.plot.height = 6)  # Adjust width and height as needed
# Plot bar chart with custom design
barplot(top_10_companies$Total_Volume,
names.arg = top_10_companies$Company,
xlab = "Company",
ylab = "Total Volume",
main = "Top 10 Companies with Highest Total Volume in Last 6 Months",
border = "black",
ylim = c(0, max(total_volume$Total_Volume) * 1.2),
las = 2,  # Rotate company names if needed for better visualization
cex.names = 0.8,  # Adjust font size for company names
cex.lab = 1.2,  # Adjust font size for axis labels
cex.main = 1.5,  # Adjust font size for main title
width = 0.5)  # Adjust bar width as needed
# Check for missing values
missing_values <- sum(is.na(data))
missing_values
# Remove rows with missing values
data <- data[complete.cases(data), ]
#Check Date Format: Confirm that the 'Date' column is in the correct date format.
library(lubridate)
is.Date(data$Date)
data$Date <- as.Date(data$Date)
# Check unique values in the 'Date' column
length(unique(data$Date)) == nrow(data)
#Check for Negative Values: Ensure that there are no negative values in numerical columns where it's not appropriate (e.g., 'Open', 'High', 'Low', 'Close', 'Adj.Close', 'Volume').
any(data$Open < 0)
any(data$High < 0)
any(data$Low < 0)
any(data$Close < 0)
any(data$Adj.Close < 0)
any(data$Volume < 0)
#Check Consistency: Ensure that 'High' values are greater than or equal to 'Low' values
any(data$High < data$Low)
# Summary statistics for the 'Close' column after cleaning
summary(data$Close)
# Display the cleaned data
data
# Summary statistics for the 'Close' column
summary(data)
# Boxplot to visualize outliers
boxplot(data$Close, main = "Boxplot of Close Prices")
# Calculate the Interquartile Range (IQR)
Q1 <- quantile(data$Close, 0.25)
Q3 <- quantile(data$Close, 0.75)
IQR <- Q3 - Q1
# Define the lower and upper bounds for outlier detection
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
# Identify outliers
outliers <- data$Close[data$Close < lower_bound | data$Close > upper_bound]
# Remove outliers
data_clean <- data[!(data$Close %in% outliers), ]
# Summary statistics for the cleaned dataset
summary(data_clean$Close)
# Boxplot of the cleaned dataset
boxplot(data_clean$Close, main = "Boxplot of Close Prices (Cleaned)")
# Summary statistics for the 'Close' column after cleaning
summary(data$Close)
# Display the cleaned data
data
# Summary statistics for the 'Close' column
summary(data)
# Boxplot to visualize outliers
boxplot(data$Close, main = "Boxplot of Close Prices")
# Calculate the Interquartile Range (IQR)
Q1 <- quantile(data$Close, 0.25)
Q3 <- quantile(data$Close, 0.75)
IQR <- Q3 - Q1
# Define the lower and upper bounds for outlier detection
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
# Identify outliers
outliers <- data$Close[data$Close < lower_bound | data$Close > upper_bound]
# Remove outliers
data_clean <- data[!(data$Close %in% outliers), ]
# Summary statistics for the cleaned dataset
summary(data_clean$Close)
# Boxplot of the cleaned dataset
boxplot(data_clean$Close, main = "Boxplot of Close Prices (Cleaned)")
